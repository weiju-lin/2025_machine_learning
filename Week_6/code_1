import re
import xml.etree.ElementTree as ET
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from pathlib import Path
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score, confusion_matrix, ConfusionMatrixDisplay
from sklearn.utils import resample
from dataclasses import dataclass
from typing import Tuple


def read_cwa_grid(xml_path, dx=0.03):
    ns = {'cwa': 'urn:cwa:gov:tw:cwacommon:0.1'}
    root = ET.parse(xml_path).getroot()

    blon = float(root.find('.//cwa:BottomLeftLongitude', ns).text)   # 120.00
    tlon = float(root.find('.//cwa:TopRightLongitude',  ns).text)    # 121.98
    blat = float(root.find('.//cwa:BottomLeftLatitude', ns).text)    # 21.88
    tlat = float(root.find('.//cwa:TopRightLatitude',   ns).text)    # 25.45

    nx = int(round((tlon - blon) / dx)) + 1  # 67
    ny = int(round((tlat - blat) / dx)) + 1  # 120

    node = root.find('.//cwa:Content', ns)
    txt = node.text

    patt = r'[+\-]?(?:\d+(?:\.\d*)?|\.\d+)(?:[Ee][+\-]?\d+)?'
    tokens = re.findall(patt, txt)
    vals = np.array(list(map(float, tokens)), dtype=np.float64)

    expected = nx * ny
    grid = vals.reshape(ny, nx)

    lons = blon + np.arange(nx) * dx
    lats = blat + np.arange(ny) * dx

    lon_grid, lat_grid = np.meshgrid(lons, lats)
    return grid, lon_grid, lat_grid

@dataclass
class QDA:
    reg: float = 1e-6

    def fit(self, X, y):
        y = y.astype(int)
        self.phi_ = np.mean(y)
        self.mu0_ = X[y == 0].mean(axis=0)
        self.mu1_ = X[y == 1].mean(axis=0)
        self.Sigma0_ = np.cov(X[y == 0].T) + self.reg * np.eye(X.shape[1])
        self.Sigma1_ = np.cov(X[y == 1].T) + self.reg * np.eye(X.shape[1])
        self.inv0_, self.inv1_ = np.linalg.inv(self.Sigma0_), np.linalg.inv(self.Sigma1_)
        return self

    def decision_function(self, X):
        def log_gauss(X, mu, invSigma, detSigma):
            diff = X - mu
            return -0.5 * np.sum(diff @ invSigma * diff, axis=1) - 0.5 * np.log(detSigma)
        det0, det1 = np.linalg.det(self.Sigma0_), np.linalg.det(self.Sigma1_)
        g0 = log_gauss(X, self.mu0_, self.inv0_, det0) + np.log(1 - self.phi_)
        g1 = log_gauss(X, self.mu1_, self.inv1_, det1) + np.log(self.phi_)
        return g1 - g0  #if >0: class 1

    def predict(self, X):
        return (self.decision_function(X) >= 0).astype(int)

def plot_decision_boundary(model, X, y, title="GDA Decision Boundary"):
    x_min, x_max = X[:,0].min() - 0.1, X[:,0].max() + 0.1
    y_min, y_max = X[:,1].min() - 0.1, X[:,1].max() + 0.1
    xx, yy = np.meshgrid(np.linspace(x_min, x_max, 400),
                         np.linspace(y_min, y_max, 400))
    grid = np.c_[xx.ravel(), yy.ravel()]
    zz = model.predict(grid).reshape(xx.shape)

    plt.figure(figsize=(6,5))
    plt.contourf(xx, yy, zz, alpha=0.25, levels=[-0.5, 0.5, 1.5])
    plt.contour(xx, yy, model.decision_function(grid).reshape(xx.shape),
                levels=[0], linewidths=2, colors="k")
    plt.scatter(X[:,0], X[:,1], c=y, s=8, cmap="bwr", edgecolors="k", alpha=0.6)
    plt.xlabel("Longitude"); plt.ylabel("Latitude")
    plt.title(title)
    plt.colorbar(label="Label (0=Invalid, 1=Valid)")
    plt.tight_layout()
    plt.show()

xml_path = "O-A0038-003.xml"
grid, lon_grid, lat_grid = read_cwa_grid(xml_path)
NOVAL = -999.0
label = (grid != NOVAL).astype(np.int8)

#convert grid data into a flat DataFrame
df_cls = pd.DataFrame({
    "lon": lon_grid.ravel(),
    "lat": lat_grid.ravel(),
    "label": label.ravel()
})

#train/test split
X_all = df_cls[["lon", "lat"]].values
y_all = df_cls["label"].values
X_tr, X_te, y_tr, y_te = train_test_split(
    X_all, y_all, test_size=0.2, stratify=y_all, random_state=42
)

#convert to DataFrame for resampling convenience
df_tr = pd.DataFrame({"lon": X_tr[:,0], "lat": X_tr[:,1], "label": y_tr})
df_te = pd.DataFrame({"lon": X_te[:,0], "lat": X_te[:,1], "label": y_te})

#oversample minority class (only in training set)
df0 = df_tr[df_tr.label == 0]
df1 = df_tr[df_tr.label == 1]
df1_up = resample(df1, replace=True, n_samples=len(df0), random_state=42)
df_tr_bal = pd.concat([df0, df1_up], ignore_index=True).sample(frac=1, random_state=42)

X_tr_bal = df_tr_bal[["lon","lat"]].values
y_tr_bal = df_tr_bal["label"].values
X_te = df_te[["lon","lat"]].values
y_te = df_te["label"].values

#train QDA model
model = QDA(reg=1e-6).fit(X_tr_bal, y_tr_bal)
#reset the prior to reflect the original training distribution
model.phi_ = y_tr.mean()

#evaluate on test set
y_pred = model.predict(X_te)
acc = accuracy_score(y_te, y_pred)
print(f"Test Accuracy: {acc:.4f}")

#confusion matrix
cm = confusion_matrix(y_te, y_pred)
disp = ConfusionMatrixDisplay(confusion_matrix=cm, display_labels=[0,1])
disp.plot(cmap="Blues", values_format="d")
plt.title("QDA Confusion Matrix (train oversampled, prior reset)")
plt.tight_layout()
plt.show()

#decision boundary
plot_decision_boundary(model, X_te, y_te, "QDA Decision Boundary (Test Set)")
